#include "crypto.h"
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <stdexcept>
#include <cstring>
#include <iomanip>
#include <sstream>

namespace RemoteAccess {

std::string Crypto::generateSalt(size_t length) {
    std::vector<uint8_t> salt(length);
    if (RAND_bytes(salt.data(), length) != 1) {
        throw std::runtime_error("Failed to generate random salt");
    }
    return base64Encode(salt);
}

std::string Crypto::generateToken(size_t length) {
    std::vector<uint8_t> token(length);
    if (RAND_bytes(token.data(), length) != 1) {
        throw std::runtime_error("Failed to generate random token");
    }
    
    // Convert to hex string
    std::stringstream ss;
    for (auto byte : token) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    }
    return ss.str();
}

std::string Crypto::hashPassword(const std::string& password, const std::string& salt) {
    // Using PBKDF2-SHA256 (Argon2 requires additional library)
    std::vector<uint8_t> salt_bytes = base64Decode(salt);
    std::vector<uint8_t> hash(32); // 256 bits
    
    const int iterations = 100000;
    
    if (PKCS5_PBKDF2_HMAC(
            password.c_str(), password.length(),
            salt_bytes.data(), salt_bytes.size(),
            iterations,
            EVP_sha256(),
            hash.size(), hash.data()) != 1) {
        throw std::runtime_error("Failed to hash password");
    }
    
    return base64Encode(hash);
}

bool Crypto::verifyPassword(const std::string& password, const std::string& salt, const std::string& hash) {
    std::string computed_hash = hashPassword(password, salt);
    return computed_hash == hash;
}

std::vector<uint8_t> Crypto::encrypt(const std::vector<uint8_t>& plaintext, const std::string& key) {
    // Generate IV
    std::vector<uint8_t> iv(IV_LENGTH);
    if (RAND_bytes(iv.data(), IV_LENGTH) != 1) {
        throw std::runtime_error("Failed to generate IV");
    }
    
    // Derive key from string
    std::vector<uint8_t> key_bytes(KEY_LENGTH);
    SHA256(reinterpret_cast<const unsigned char*>(key.c_str()), key.length(), key_bytes.data());
    
    // Create cipher context
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        throw std::runtime_error("Failed to create cipher context");
    }
    
    // Initialize encryption
    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, key_bytes.data(), iv.data()) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to initialize encryption");
    }
    
    // Allocate output buffer
    std::vector<uint8_t> ciphertext(plaintext.size() + EVP_CIPHER_block_size(EVP_aes_256_gcm()));
    int len = 0;
    int ciphertext_len = 0;
    
    // Encrypt data
    if (EVP_EncryptUpdate(ctx, ciphertext.data(), &len, plaintext.data(), plaintext.size()) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Encryption failed");
    }
    ciphertext_len = len;
    
    // Finalize encryption
    if (EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Encryption finalization failed");
    }
    ciphertext_len += len;
    
    // Get authentication tag
    std::vector<uint8_t> tag(TAG_LENGTH);
    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, TAG_LENGTH, tag.data()) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to get authentication tag");
    }
    
    EVP_CIPHER_CTX_free(ctx);
    
    // Resize ciphertext to actual length
    ciphertext.resize(ciphertext_len);
    
    // Combine: IV + ciphertext + tag
    std::vector<uint8_t> result;
    result.insert(result.end(), iv.begin(), iv.end());
    result.insert(result.end(), ciphertext.begin(), ciphertext.end());
    result.insert(result.end(), tag.begin(), tag.end());
    
    return result;
}

std::vector<uint8_t> Crypto::decrypt(const std::vector<uint8_t>& ciphertext, const std::string& key) {
    if (ciphertext.size() < IV_LENGTH + TAG_LENGTH) {
        throw std::runtime_error("Invalid ciphertext length");
    }
    
    // Extract IV, ciphertext, and tag
    std::vector<uint8_t> iv(ciphertext.begin(), ciphertext.begin() + IV_LENGTH);
    std::vector<uint8_t> tag(ciphertext.end() - TAG_LENGTH, ciphertext.end());
    std::vector<uint8_t> encrypted_data(
        ciphertext.begin() + IV_LENGTH,
        ciphertext.end() - TAG_LENGTH
    );
    
    // Derive key from string
    std::vector<uint8_t> key_bytes(KEY_LENGTH);
    SHA256(reinterpret_cast<const unsigned char*>(key.c_str()), key.length(), key_bytes.data());
    
    // Create cipher context
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        throw std::runtime_error("Failed to create cipher context");
    }
    
    // Initialize decryption
    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, key_bytes.data(), iv.data()) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to initialize decryption");
    }
    
    // Set authentication tag
    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, TAG_LENGTH, tag.data()) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to set authentication tag");
    }
    
    // Allocate output buffer
    std::vector<uint8_t> plaintext(encrypted_data.size());
    int len = 0;
    int plaintext_len = 0;
    
    // Decrypt data
    if (EVP_DecryptUpdate(ctx, plaintext.data(), &len, encrypted_data.data(), encrypted_data.size()) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Decryption failed");
    }
    plaintext_len = len;
    
    // Finalize decryption (this also verifies the tag)
    if (EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Decryption finalization failed - authentication tag mismatch");
    }
    plaintext_len += len;
    
    EVP_CIPHER_CTX_free(ctx);
    
    // Resize plaintext to actual length
    plaintext.resize(plaintext_len);
    
    return plaintext;
}

std::string Crypto::base64Encode(const std::vector<uint8_t>& data) {
    BIO* bio = BIO_new(BIO_s_mem());
    BIO* b64 = BIO_new(BIO_f_base64());
    bio = BIO_push(b64, bio);
    
    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
    BIO_write(bio, data.data(), data.size());
    BIO_flush(bio);
    
    BUF_MEM* buffer_ptr;
    BIO_get_mem_ptr(bio, &buffer_ptr);
    
    std::string result(buffer_ptr->data, buffer_ptr->length);
    
    BIO_free_all(bio);
    
    return result;
}

std::string Crypto::base64Encode(const std::string& data) {
    std::vector<uint8_t> bytes(data.begin(), data.end());
    return base64Encode(bytes);
}

std::vector<uint8_t> Crypto::base64Decode(const std::string& encoded) {
    BIO* bio = BIO_new_mem_buf(encoded.data(), encoded.length());
    BIO* b64 = BIO_new(BIO_f_base64());
    bio = BIO_push(b64, bio);
    
    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
    
    std::vector<uint8_t> result(encoded.length());
    int decoded_length = BIO_read(bio, result.data(), encoded.length());
    
    BIO_free_all(bio);
    
    if (decoded_length < 0) {
        throw std::runtime_error("Failed to decode base64");
    }
    
    result.resize(decoded_length);
    return result;
}

} // namespace RemoteAccesss